<!-- Tool-specific (e.g. Storybook) imports & exports go here -->
<!-- Metadata about the component -->
export const componentMetaData = {
  /*
   *  [REQUIRED] URL to the relevant directory that contains the (main) source
   *  code for this component
   */
  sourceCodeUrl:
    "https://github.com/some-org/some-repo/tree/main/path/to/component-name/",
  /*
   *  [REQUIRED] Name of the NPM package this component is published in
   */
  npmPackage: "@some-org/some-package",
  /*
   * [REQUIRED] The version of the NPM package that this component first
   * appeared in.
   */
  npmPackageSince: "1.2.3",
  /*
   * [OPTIONAL] A list of synonymous names that someone might search for when
   * trying find this component. For example, a "Dialog" component might list
   * "Modal" and "Prompt" as its alsoKnownAs names.
   */
  alsoKnownAs: ["Other Name", "Another Name", "Different Name"],
  /*
   * [OPTIONAL] A list of other components that are related to this component
   * and the nature of that relationship.
   */
  relatedComponents: [
    /*
     * Each related component must list name & relationship:
     */
    {
      name: "Other Component Name",
      /*
        Permitted values for "relationship" are:
        - contains:  This component contains the other component (e.g. Dropdown
                     _contains_ List)
        - similarTo: This component is similar to the other component (e.g. a
                     Switch _similarTo_ Checkbox)
      */
      relationship: "contains",
    },
    {
      name: "Another Component Name",
      relationship: "similarTo",
    },
    // ...
  ],
};
# Data grid

## Overview

<!--
  Live component demo here of the default/most common usage.
  For live demos in Storybook use:
  <Canvas>
    <Story id="..." />
  </Canvas>
-->

A grid presents tabular information that has columns and rows. The grid is particularly useful if the tabular information is editable or interactive.
The grid provides users with intuitive and efficient keyboard navigation, filtering, content editing, selection, and copy-and-paste.
The grid is virtualized. Only the visible part is rendered to the DOM.

## Configurations

<!--
  A visual list of possible configurations of the component.
  The purpose is to convey the main features and/or usage options of the
  component (e.g. the Data Grid's striped rows might be a "configuration" to
  showcase here). The configurations listed here should aim to be comprehensive,
  but not necessarily exhaustive (some complex components may have vast numbers
  of possible permutations, so listing out each one would be impossible and
  overwhelming to readers).

  Each configuration should have its own section following the structure outlined
  below:
-->

### Column configuration

The grid columns can be configured using the `GridColumn` component.

The grid package contains three types of predefined columns:

- `RowSelectionCheckboxColumn`: cell values of type `RowSelectionCheckboxCellValue` contain checkboxes, allow multiple selection and values are left aligned by default.
- `RowSelectionRadioColumn`: cell values of type `RowSelectionRadioCellValue` contain radio buttons, allow single selection only and values are left aligned by default.
- `NumericColumn`: cell values of type `NumericCellValue`, values are right aligned only.

Each one of them renders a `GridColumn` with a specific set of props. You can easily create any project-specific column types tailored to your needs using the same approach.

<!--
  A live example of the component configuration, with access to the corresponding
  source code.
  In Storybook this is done using something like:

  <Canvas>
    <Story id="..." />
  </Canvas>
-->

#### Grouping columns

Columns can be grouped using the `ColumnGroup` component.

Note: whenever a `ColumnGroup` component is present, all other grids' children will also need to be wrapped within a `ColumnGroup` component.

### Configuring rows

The grid rows are created by providing an array of objects in the `rowData` property of the grid. rowData also accepts sparse arrays, array where most of the elements have values zero or null. When used in combination with the `onVisibleRowRangeChange` callback this allows for lazy loading (server-side data) scenarios.

Here's an example that details using sparse array and `onVisibleRowRangeChange` callback.

<!--
  A live example of the component configuration, with access to the corresponding
  source code.

  In Storybook this is done using something like:

  <Canvas>
    <Story id="..." />
  </Canvas>
-->

### Selecting rows

The grid supports three variants of row selection:

- Single row selection
- Multi-row selection
- None (rows cannot be selected)
- `RowSelectionCheckboxColumn` is useful in multi row selection mode, and `RowSelectionRadioColumn` works best in single row selection mode. Both are optional.

#### Uncontrolled mode

In uncontrolled mode you can provide `defaultSelectedRowIdxs` and the grid maintains the selection state. It accepts `number[]`, and works only when `rowSelectionMode` is single or multi.

<!--
  A live example of the component configuration, with access to the corresponding
  source code.

  In Storybook this is done using something like:

  <Canvas>
    <Story id="..." />
  </Canvas>
-->

#### Controlled mode

In controlled mode you can provide `selectedRowIdxs` and update it when the `onRowsSelected` callback is invoked. Below is an example of how to use controlled selection mode to synchronize selection in two grids.

<!--
  A live example of the component configuration, with access to the corresponding
  source code.

  In Storybook this is done using something like:
  <Canvas>
    <Story id="..." />
  </Canvas>
-->

The second way to customize cell appearance is the `cellComponent` property. Unlike `cellValueComponent` it replaces the entire cell element rather than its content and allows you to implement more radical customization scenarios. Please note that if you override `cellComponent` you will need to handle all basic functionality typically provided by the default cell implementation, therefore it is recommended that you only use `cellComponent` if `cellValueComponent` does not provide enough flexibility.

### Customizing headers

Column headers and column group headers can be customized using the headerValueComponent property which is demonstrated by the grid below.

- The "Items sold" column group has a group of toggle buttons that change the appearance of the group between "monthly", "quarterly" and "summary" modes.
- The "Item" column group has a button to toggle between pinned and unpinned modes.
- The "Name" and "Price" columns have custom headers that indicate sort direction.

This grid also shows an example of a custom cell displaying a basic chart. Switch the "Items sold" column to "summary" mode to see it

<!--
  A live example of the component configuration, with access to the corresponding
  source code.

  In Storybook this is done using something like:

  <Canvas>
    <Story id="..." />
  </Canvas>
-->

### Editing cells

The grid allows you to make cell values editable in place.

Use the CellEditor (a non-rendered) component as a child of GridColumn to make the column editable. A non-rendered component, a.k.a. renderless component is a reusable React component that renders nothing i.e. return null, used mainly to manage data and state. CellEditor is expected to have one child representing the specific editor component to use for the column. The child of the CellEditor component gets rendered in the focused cell when the grid goes to edit mode.

We have two sample components created for use as CellEditor's child, i.e. TextCellEditor and NumericCellEditor. You can easily create any components tailored to your needs using the same approach.

<!--
  A live example of the component configuration, with access to the corresponding
  source code.

  In Storybook this is done using something like:

  <Canvas>
    <Story id="..." />
  </Canvas>
-->

To trigger edit mode on cells, users can use either their keyboard or mouse:
- keyboard: press either the backspace or F2 key, alternatively simply start typing
- mouse: double click

## Usage

### When to use Component Name

<!-- Bulleted list of scenarios in which this component can be used  -->

- Data input, such as editing notional values.
- Real-time data display, such as executed trades.
- Inline cell or row-based actions, such as cancelling trades.

### Accessibility

<!--
  OPTIONAL: Remove this section if it is not applicable.
  Describe any considerations the users may need to take into account when using
  the component. For example:

  - Accessibility decisions that deviate from industry standard. (e.g., we've
    introduced an arrow key navigation, where usually is only tab).
  - Accessibility requirements that drive design (e.g., how multi-column forms
    should wrap).
  - Best practices regarding accessible content (e.g., error message
    announcements must not rely on descriptions that require the user to
    visually or audibly perceive content).
  - Best practices regarding implementation (e.g., to make sure this component
    is accessible be sure to provide a relevant alt text).
-->

The grid is accessible by assistive technologies like screen readers, and provides full WAI-ARIA support.

## Styling

### Additional materials

<!--

  OPTIONAL: Remove this section if it is not applicable.
  Add a bulleted list of links to additional, component-specific materials.
  Note that only publicly accessible pages can be linked to.
-->

- [Figma stickersheet](https://www.figma.com/file/xqqKG90bV9yT8xBJvWayzJ/Data-Grid-V1?node-id=827%3A9904&t=ShjskEHH4UXYTov7-0)

## Code

### Import

<!--
  Show the typical import statement used to include this component in your
  code.
-->

```js
import { Grid, GridColumn } from "@salt-ds/data-grid";
```

### Writing tests for Grid

The grid utilizes virtualization to load content and renders only what’s in the viewport. As previously fetched data leave the viewport (rows/columns scrolled out of view in grid), so do the DOM nodes.

Note: if your test expects an element to be rendered, and it is out of the viewport, the test will not find the element - that is expected behaviour. Virtual DOM environments like JSDOM in Jest do not have any dimensions, therefore will not render any rows. We recommend using Cypress for testing the grid. To make tests work, ensure your grid is big enough and have scrolling implemented, closely mimicking how a user would experience using it.

### Props

<!--

  Insert an auto-generated table of the props for this component and their

  respective descriptions, data types, etc. here.

  In Storybook this is done like so:

  <ArgsTable of={ComponentName} />

-->
